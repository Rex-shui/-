#### 2.4死锁

* 死锁产生的原因
  * 系统资源的竞争（不可剥夺资源）
  * 进程推进顺序非法
* 死锁产生的必要条件
  * 互斥条件
  * 不可剥夺条件
  * 请求并保持条件
  * 循环等待条件
* 死锁的处理策略
  1. 死锁预防（破环“死锁产生的必要条件”中的一个或多个）
  
  2. 避免死锁
  
  3. 死锁的检测及解除
  
     &emsp;

#### 死锁避免（系统安全状态）

安全状态是指系统能按**某种进程推进顺序**（P1，P2，···，Pn）为每个进程Pi分配所需的资源，直至满足每个进程对资源的最大需求，使每个进程都可顺序完成。

&emsp;

* 银行家算法

  ```
  可利用资源向量Available
  最大需求矩阵Max、分配矩阵Allocation、需求矩阵Need
  Need = Max - Allocation
  ```

  &emsp;


* 示例

  资源类型A有10个实例，B有5个实例，C有7个实例。在时间T0，系统状态如下：

  | &nbsp; | Allocation | Max   | Available |
  | ------ | ---------- | ----- | --------- |
  |        | A B C      | A B C | A B C     |
  | P0     | 0 1 0      | 7 5 3 | 3 3 2     |
  | P1     | 2 0 0      | 3 2 2 |           |
  | P2     | 3 0 2      | 9 0 2 |           |
  | P3     | 2 1 1      | 2 2 2 |           |
  | P4     | 0 0 2      | 4 3 3 |           |

  &emsp;

  | &nbsp; | Need  |
  | ------ | ----- |
  |        | A B C |
  | P0     | 7 4 3 |
  | P1     | 1 2 2 |
  | P2     | 6 0 0 |
  | P3     | 0 1 1 |
  | P4     | 4 3 1 |

  存在安全序列&lt;P1，P3，P4，P0，P2&gt;满足安全状态

&emsp;

#### 死锁检测

等待图

&emsp;

#### 例题

---

* 系统中有3个不同的临界资源R1，R2和R3，被4个进程P1，P2，P3，P4共享。各进程对资源的需求为：P1申请R1和R2，P2申请R2和R3，P3中请R1和R3，P4申请R2。若系统出现死锁，则处于死锁状态的进程数至少是（**3**）。


